%Jörn
\section{Fachkonzept}
In unserem Entwicklertool ``Eclipse'' haben wir die Klassen in vier verschiedene
Projekte aufgeteilt:
\begin{enumerate}
  \item {\textbf{Server}}, enthält alle Klassen, die nur auf dem Server benötigt
  werden.
  \item {\textbf{Client}}, enthält alle Klassen, die nur auf dem Client benötigt
  werden.
  \item{\textbf{Shared}}, enthält Klassen, die jeweils auf dem Server und
  dem Client benötigt und eingebunden werden (z.B. Klassen zur Kommunikation).
  \item{\textbf{UnitTests}}, enthält alle Unit-Tests, die nicht für die
  eigentliche Anwendung benötigt werden.
\end{enumerate}

Im \ref{ooa} wurde bereits das Klassendiagramm der
Analysephase näher erläutert.
Bei der Implementierung auf Basis dieses Klassenmodells haben wir aber noch
einige Änderungen und Einschränkungen vorgenommen. Im folgenden Abschnitt werden
diese Unterschiede und dessen Hintergründe näher erläutert.

Durch Prioritäten die wir in der Entwurfsphase gesätzt haben, sind gegenüber dem
OOA-Diagramm auch einige Bereiche weggefallen:
\begin{itemize}
  \item {\textbf{Marketing}}\\
  Das Marketing und die dazugehörige Marktforschung und Werbung haben zeitlich
  nicht mehr in den Plan gepasst.
  \item{\textbf{Mitarbeiter}}\\
  Die Mitarbeiter als einzelnes Objekt zu modellieren erschien uns im Laufe der
  Entwurfsphase in einem Gebäudeintensiven Unternehmen für keine Notwendigkeit
  mehr. Deswegen haben wir uns nun dazu entschieden auf eine Mitarbeiteranzahl
  und weiteres zu verzichten und diese vielmehr in die laufenden Kosten der
  einzelnen Kraftwerke mit einfließen zu lassen.
\end{itemize}



\subsection{Client-Server}


\begin{figure}
\centering
\centering
\includegraphics[width=1.1\textwidth]{se-wa-jpg/OOD-Map}
\caption{Klassendiagramm zu den Kommunikationsklassen}
\label{OOD-Map}
\end{figure}

Die Client-Server Architektur, die bei unserem Planspiel angewandt wird,
ermöglicht es mehreren Spielern ihren Spielzug gleichzeitig zu absolvieren.
Zwar verringert dies die Wartezeiten der Spieler im Gegensatz zum
Hotseat-Modell, allerdings muss bei einem gemeinsamen Server und mehreren
Clienten darauf geachtet werden, dass es zu keinen Dateninkonsistenzen kommt.
An der ``Thread-per-Connection''-Methode hat sich seit der Analysephase (siehe
\ref{ooa}) nichts geändert, weswegen hier darauf nicht näher eingegangen wird.

In \ref{OOD-Map} ist die Klassenstruktur abgebildet, die alle Daten enthält, die
für alle Spieler interessant sind und indirekt auch von diesen geändert werden
können. Hierbei haben wir uns dazu entschlossen nicht alle Entscheidungen des
Spielers dem Server mitzuteilen, sondern einige Eingaben auf Client-Seite
zu bearbeiten, um den Server nicht unnötig zu belasten und den
Datenverkehr zu vermindern. Zum Beispiel wird das Vermögen eines Unternehmens
komplett auf Client-Seite bearbeitet, da es für die anderen Spieler im Spiel
nicht sichtbar gemacht werden soll.\\
Um Dateninkonsistenz zu vermeiden werden alle Änderungen, die alle Spieler
betreffen, direkt an den Server gesendet, dieser wertet die Änderungen aus
überträgt sie gegebenenfalls in den entsprechenden Objekte. Zu Rundenbeginn
wird nun die gesamt Objektstruktur, die in einem Objekt der 'Map'-Klasse auf
Serverseite gespeichert ist, an alle Clients übertragen. Dadurch, dass nur der
Server solche Änderungen vornehmen kann und diese auch nicht von verschiedenen
'Connection'-Threads gleichzeitig vorgenommen können (``Synchronized''), wird
die richtige Datenhaltung sichergestellt.

Während der Analysephase war es angedacht, Verträge mit einer Stadt unabhängig
vom Rundenende zu schließen. Diese Idee wurde während der Entwcklung verworfen,
so dass nun jeder Spieler seine Vertragsvorschläge dem Server während der Runde
zusendet, der Server nach der Runde die Kunden jedes Spielers
errechnet und zum nächsten Rundenanfang diese den Spielern mitteilt.\\
Wie in \ref{OOD-Map} zu sehen ist, haben wir uns deswegen dazu entschieden den
'Contract', der vorher unter dem Unternehmen in dem Bereich der Beziehungen zu
den Regionen angeordnet war, nun der 'Map' und darin der 'CityRegion' zu
unterordnen.\\
Diese Änderung in der Struktur der Fachlogik erlaubt es dem Server weiterhin,
alle Daten, die jede Runde den Spielern zugeschickt werden, in einer einzigen
Objektstruktur zu übertragen.
Dies ermöglicht zum einen eine einfache Kommunikation vom Server zum Client und
zum anderen kann nun auch der Client alle wichtigen Änderungen der Runde aus
einem einzigen Objekt auslesen, in dem er die neu erhaltene 'Map' mit der
vorhandenen aus der vergangenen Runde vergleicht.

Im folgenden werden die einzelnen Klassen, die vom Server zu dem Client
übertragen werden, näher erläutert:
\begin{itemize}
  \item {\textbf{Klasse Map}}\\
  Die Klasse Map enthält zum Einen alle Regionen der Spielkarte, die zu Beginn
  des Spiels vom Server generiert werden und zum Anderen die
  Strombörse('EnergyExchange') und den Ressourcenmarkt. Außerdem werden in ihr
  die Kunden der einzlnen Spieler in den verschiedenen Städten berechnet.
  \item{\textbf{Klasse RessourceMarket}}\\
  Der Ressourcenmarkt setzt sich aus den drei unterschiedlichen Rohstoffen
  zusammen, die in unserem SPiel vorhanden sind. Die Preise für die Rohstoffe
  sind in dem Programm als Konstanten festgesetzt und ändern sich nicht mit der
  Zeit.
  \item{\textbf{Klasse EnergyExchange}}\\
  Die Strombörse im Spiel hat einen schwankenden Preis. Dieser reguliert sich
  aus Angebot und Nachfrage. Jedes mal wenn ein Spieler einen Stromhandel
  abschließt, schickt der Client eine kleine Nachricht über die höhe des Handels
  an den Server, der daraufhin den neuen Preis für die nächste Runde berechnet.
  \item{\textbf{Klasse Region und Klasse Coords}}\\
  Die Klasse Region ist dafür gedacht, dass sie mit ihren Koordinaten, die in
  der Klasse Coords gespeichert sind, eindeutig ermittelt werden kann. Die
  Region ist nich dafür gedacht, dass sie für sich instanziiert wird, sondern
  mit Hilfe von Vererbung entweder als Ressourcenregion oder Stadtregion benutzt
  wird.
  \item{\textbf{Klasse CityRegion und Klasse Contract}}\\
  Die Stadtregion enthält alle Informationen über die Einwohner der Stadt und
  die Verträge mit den verschiedenen Energielieferanten. Die Stadt wird mit
  einer Einwohnerzahl und verschiedenen Kennziffern zum Spielstart generiert,
  während die Kundenzahlen, die in den Contracts gespeichert sind, sich jede
  Runde durch Preisänderungen der Spieler ändern können. Jede Stadt hat für
  jedes Unternehmen, dass in ihr Kunden besitzt, ein seperates Contract-Objekt.
  \item{\textbf{Klasse RessourceRegion}}\\ 
  Die RessourceRegion wird mit einem bestimmten RessourceType (siehe
  Enumeration RessouurceType) und gegebenenfalls einer Menge des Rohstoffes zum
  Spielstart generiert. Für erneuerbare Energien, wie z.B. Wasser entfällt
  natürlich die Rohstoffmenge. Während des Spiels können Spieler auf die
  Regionen bieten, um sie bebauen zu können. Diese Gebote werden an den Server
  gesendet, der dann den Zuschlag an ein Unternehmen gibt, der danach zum
  Besitzer der Region wird. Zudem meldet der Besitzer der Region dem Server,
  sobald er ein Gebäude in einer Region fertiggestellt hat. Dieser schreibt dies
  dann in das Region-Objekt, sodass dies auch für die anderen Spieler sichtbar
  wird.
  
\end{itemize}


\subsection{Gebäude}

\begin{figure}
\centering
\centering
\includegraphics[width=1.0\textwidth]{se-wa-jpg/OOD-Building}
\caption{Klassendiagramm zu den Gebäude}
\label{OOD-Building}
\end{figure}

Die Abteilung 'Investment', die für die Verwaltung der Gebäude in dem
Unternehmen zuständig ist wurde im Vergleich zur Analysephase in einigen Punkten
geändert. Der 'InvestmentManager' aus der Analyse fällt in unserem Entwurf weg.
Die Funktion die die Klasse übernommen hätte, das hinzufügen von Gebäuden, wird
stattdessen von der 'Company'-Klasse übernommen.\\
Zudem gibt es nun keine Objekte mehr für die Grundstücke, die das Unternehmen
besitzt. Diese Unterscheiden sich nicht voneinander, so dass die Spieler einfach
als Besitzer der Region in das jeweilige Objekt geschrieben werden kann und
keine gesonderte Klasse benötigt wird.
Auch die Unterscheidung zwischen erneuerbaren Energieen wird nun nicht mehr in
Form von Klassen, sondern mit Hilfe des 'RessourceType' des Kraftwerks.

Alle verblienden Klassen werden im  folgenden erläutert:
\begin{itemize}
  \item{\textbf{Klasse Investment und Klasse Building}}\\ 
  Die Klassen Investment und Building legen die Grundlagen für die beiden
  Gebäudetypen: die Mine und das Kraftwerk. Hierzu werden bereits im Investment
  der Kaufpreis, der aktuelle Buchwert und die dazugehörigen, jährlichen
  Abschreibungen beschrieben. Die Klasse Building ergänzt diese Informationen
  noch um eine maximale Produktion und die derzeitige Auslastung. Darüber hinaus
  wird gespeichert ob der Bau bereits beendet wurde und, wenn nicht, wie lange
  der Bau noch benötigt. Auch die aktuelle Produktion und die laufenden Kosten
  können hier abgelesen werden.
  \item{\textbf{Klasse Mine}}\\
  Zuzüglich zu dem Gebäude und dem Investment besitzt die Mine noch ein
  Ressourcentyp und eine Referenz auf die 'RessourceRelation', in der die
  verbleibende Menge des Rohstofffeldes gespeichert wird. Damit kann jede Runde
  die Menge an produzierten Rohstoffen berechnet werden.
  \item{\textbf{Klasse PowerStation}}\\ 
  Zu dem aktuellen Auslastungsfaktor im Gebäude, wird in dem Kraftwerk noch ein
  Indikator für die Verstellbarkeit. Dieser beschreibt wie stark die laufenden
  Kosten eingespart werden können, in dem die Auslastung gesenkt wird. Des
  weiteren beinhaltet das Kraftwerk noch Wartungskosten, die, sofern sie
  eingespart werden, möglicherweise Reparaturen erforderlich machen. Auch den
  Verbrauch, der bei den fossilen Energien gebraucht wird, kann man hier
  ablesen.
  \item{\textbf{Klasse PowerStationRelation}}\\ 
	 Die PowerstationRelation stellt die Verbindung zwischen einem Kraftwerk und
	 einer Stadt mit Vertrag dar(siehe \ref{Opt}. Jedes Kraftwerk kann mehrere
	 solche Beziehungen besitzen.
\end{itemize}



%Matthias
\subsection{Finanzen}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{se-wa-jpg/finances}
\caption{Klassendiagramm zum Bereich der Finanzen}
\label{Finanzen}
\end{figure}
Die Finanzen sollen im Wesentlichen alle finanziell relevanten Aspekte des
Unternehmens abbilden. Hierzu gibt es das Department Finances, welches die
Bilanz, die Gewinn- und Verlustrechnung sowie alle vom Unternehmen aufgenommenen
Kredite verwaltet.

Im Einzelnen werden die relevantesten Methoden und ihre Aufgabe vorgestellt:\\
\textbf{Klasse Finances}
\begin{itemize}
  \item \textbf{addCredit(CreditType creditType):void}\\
  Mit dieser Methode lassen sich beliebig viele Kredite dem Unternehmen
  hinzufügen, wobei jeder Kredit als neues Objekt in die ArrayList ``credits''
  der Klasse Finances aufgenommen wird und der Kassenbestand des Unternehmens um die
  Darlehenshöhe erhöht wird. 
  \item \textbf{isCreditWorthyFor(CreditType creditType):boolean}
  Diese Methode gibt zurück, ob der vom Spiel vorgesehene maximale
  Verschuldungsgrad bei Aufnahme eines Kredits des Typs creditType überschritten
  würde. Damit kann im UI eine Überprüfung implementiert werden, die eine zu
  hohe Verschuldung eines Spielers verhindern kann.
  \item \textbf{isInsolvent():boolean}
  Gibt diese Methode true zurück, hat der Spieler eine zu hohe Verschuldung
  (welche durch Verluste und damit durch eine Reduktion des Eigenkapitals
  entstehen kann) und verfügt gleichzeitig über einen negativen Kassenbestand.
  Ist das der Fall, hat der Spieler das Spiel verloren.
  \item \textbf{nextRound() und nextYear()}
  werden automatisch aufgerufen und führen die Kreditzahlungen durch.
\end{itemize}
\textbf{Klasse Credit}
\begin{itemize}
  \item \textbf{payQuarter()}
  wird jede Runde aufgerufen und führt sowohl die Tilgung als auch die
  Zinszahlung durch. Bei abgezahlten Krediten betragen beide Werte 0, der
  Einfachheit halber (und der Tatsache, dass die Anzahl Kredite stark begrenzt
  ist) werden abbezahlte Kredite jedoch nicht aus der ArrayList credits der
  Klasse Finances entfernt.
\end{itemize}
\textbf{Klasse Balance}
\begin{itemize}
  \item \textbf{recalcBalance()}
  berechnet jedes Jahr die Werte der Grundstücke und Gebäude (AV), des Inventars
  und der Kasse (UV), des Eigenkapitals (EK) und des Fremdkapitals (FK).
\end{itemize}
\textbf{Klasse ProfitAndLoss}
\begin{itemize}
  \item \textbf{addXYZ(double amount)}
  da nicht alle Aufwendungen und Erträge zum Ende jeden Jahres berechnet werden
  können, addieren diese Methoden die entsprechenden Werte für die jeweiligen
  A/E und speichern sie in den Attributen \textbf{nextXYZ}.
  \item \textbf{nextYear()}
  In dieser Methode wird jedes Jahr die Gewinn- und Verlustrechnung neu
  berechnet. Dazu werden die Werte der Variablen nextXYZ in die Variablen XYZ
  überschrieben und dann auf 0 gesetzt. Alle anderen Aufwendungen und Erträge
  werden nun berechnet. Anschließend wird der Gewinn bestimmt, von dem eine
  Steuer in Höhe von 30\% abgezogen wird, sofern ein Gewinn vorhanden ist.
  Anschließend wird der Kassenbestand des Unternehmens um die Höhe der
  anfallenden Steuern reduziert.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{se-wa-jpg/bilanz-guv}
\caption{Darstellung der Bilanz und GuV im UI}
\label{Bilanz und GuV}
\end{figure}

\subsection{Warenlager}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{se-wa-jpg/Warehouse}
\caption{Klassendiagramm zum Warenlager}
\label{Warenlager}
\end{figure}
Das Warehouse beinhaltet die Verwaltung aller Rohstoffe eines Unternehmens. Es
bildet die Lagerung durch eine Komposition mit der Klasse Ware ab, es enthält
Methoden zur Erhöhung und Reduzierung des Bestands sowie zum Kauf und Verkauf
von Resourcen.

\textbf{Klasse Warehouse}
\begin{itemize}
  \item \textbf{buyWare(\ldots) / sellWare(\ldots)}
  dient zum Kauf und Verkauf von Waren. Hierbei muss nicht nur der Kassenbestand
  des Unternehmens aktualisiert werden, es entstehen gleichzeitig auch
  Aufwendungen / Erträge.
  \item \textbf{getStoredValue()}
  gibt den Wert der gelagerten Rohstoffe zurück. Dies wird zur Berechnung der
  Bilanz benötigt.
  \item \textbf{nextRound()}
  die Lagerkosten werden um einen von der Menge der gelagerten Güter abhängigen
  Wert erhöht.
  \item \textbf{nextYear()}
  Die Bestandsveränderungen im Vergleich zum letzten Jahr werden berechnet. Dies
  ist für die Gewinn- und Verlustrechnung erforderlich, da hier Aufwendungen
  bzw. Erträge entstehen.
\end{itemize}

%Olli
\subsection{Kartenerzeugung Olli}

