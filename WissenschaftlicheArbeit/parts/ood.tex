%Jörn
\section{Fachkonzept}\label{joern:fachkonzept}
In unserem Entwicklertool ``Eclipse'' haben wir die Klassen in vier verschiedene
Projekte aufgeteilt:
\begin{enumerate}
  \item {\textbf{Server}}, enthält alle Klassen, die nur auf dem Server benötigt
  werden.
  \item {\textbf{Client}}, enthält alle Klassen, die nur auf dem Client benötigt
  werden.
  \item{\textbf{Shared}}, enthält Klassen, die jeweils auf dem Server und
  dem Client benötigt und eingebunden werden (z.B. Klassen zur Kommunikation).
  \item{\textbf{UnitTests}}, enthält alle Unit-Tests, die nicht für die
  eigentliche Anwendung benötigt werden.
\end{enumerate}

Im \ref{ooa} wurde bereits das Klassendiagramm der
Analysephase näher erläutert.
Bei der Implementierung auf Basis dieses Klassenmodells haben wir aber noch
einige Änderungen und Einschränkungen vorgenommen. Im folgenden Abschnitt werden
diese Unterschiede und dessen Hintergründe näher erläutert.

Durch Prioritäten, die wir in der Entwurfsphase gesetzt haben, sind gegenüber
dem OOA-Diagramm auch einige Bereiche weggefallen:
\begin{itemize}
  \item {\textbf{Marketing}}\\
  Das Marketing und die dazugehörige Marktforschung und Werbung haben zeitlich
  nicht mehr in den Plan gepasst.
  \item{\textbf{Mitarbeiter}}\\
  Die Mitarbeiter als einzelnes Objekt zu modellieren, erschien uns im Laufe der
  Entwurfsphase in einem gebäudeintensiven Unternehmen für nicht mehr notwendig.
  Deswegen haben wir uns nun dazu entschieden, auf eine Mitarbeiteranzahl und
  weiteres zu verzichten und diese vielmehr in die laufenden Kosten der
  einzelnen Kraftwerke mit einfließen zu lassen.
\end{itemize}



\subsection{Client-Server}\label{cs}


\begin{figure}
\centering
\centering
\includegraphics[width=1.1\textwidth]{se-wa-jpg/OOD-Map}
\caption{Klassendiagramm zu den Kommunikationsklassen}
\label{OOD-Map}
\end{figure}

Die Client-Server Architektur, die bei unserem Planspiel angewandt wird,
ermöglicht es mehreren Spielern, ihren Spielzug gleichzeitig zu absolvieren.
Zwar verringert dies die Wartezeiten der Spieler im Gegensatz zum
Hotseat-Modell, allerdings muss bei einem gemeinsamen Server und mehreren
Clienten darauf geachtet werden, dass es zu keinen Dateninkonsistenzen kommt.
An der ``Thread-per-Connection''-Methode hat sich seit der Analysephase (siehe
\ref{ooa}) nichts geändert, weswegen hier nicht näher darauf eingegangen wird.

In \ref{OOD-Map} ist die Klassenstruktur abgebildet, die alle Daten enthält, die
für alle Spieler interessant sind und indirekt auch von diesen geändert werden
können. Hierbei haben wir uns dazu entschlossen, nicht alle Entscheidungen des
Spielers dem Server mitzuteilen, sondern einige Eingaben auf Client-Seite
zu bearbeiten, um den Server nicht unnötig zu belasten und den
Datenverkehr zu vermindern. Zum Beispiel wird das Vermögen eines Unternehmens
komplett auf Client-Seite bearbeitet, da es für die anderen Spieler im Spiel
nicht sichtbar gemacht werden soll.\\
Um Dateninkonsistenz zu vermeiden, werden alle Änderungen, die alle Spieler
betreffen, direkt an den Server gesendet. Dieser wertet die Änderungen aus
überträgt sie gegebenenfalls in die entsprechenden Objekte. Zu Rundenbeginn
wird nun die gesamt Objektstruktur, die in einem Objekt der 'Map'-Klasse auf
Serverseite gespeichert ist, an alle Clients übertragen. Dadurch, dass nur der
Server solche Änderungen vornehmen kann und diese auch nicht von verschiedenen
'Connection'-Threads gleichzeitig vorgenommen können (``Synchronized''), wird
die richtige Datenhaltung sichergestellt.

Während der Analysephase war es angedacht, Verträge mit einer Stadt unabhängig
vom Rundenende abzuschließen. Diese Idee wurde während der Entwicklung
verworfen, sodass nun jeder Spieler seine Vertragsvorschläge dem Server während der Runde
zusendet, der Server nach der Runde die Kunden jedes Spielers
errechnet und zum nächsten Rundenanfang diese den Spielern mitteilt.\\
Wie in \ref{OOD-Map} zu sehen ist, haben wir uns deswegen dazu entschieden, den
'Contract', der vorher unter dem Unternehmen in dem Bereich der Beziehungen zu
den Regionen angeordnet war, nun der 'Map' und darin der 'CityRegion'
unterzuordnen.\\
Diese Änderung in der Struktur der Fachlogik erlaubt es dem Server weiterhin,
alle Daten, die jede Runde den Spielern zugeschickt werden, in einer einzigen
Objektstruktur zu übertragen.
Dies ermöglicht zum einen eine einfache Kommunikation vom Server zum Client und
zum anderen kann nun auch der Client alle wichtigen Änderungen der Runde aus
einem einzigen Objekt auslesen, indem er die neu erhaltene 'Map' mit der
vorhandenen aus der vergangenen Runde vergleicht.

Im folgenden werden die einzelnen Klassen, die vom Server zum Client
übertragen werden, näher erläutert:
\begin{itemize}
  \item {\textbf{Klasse Map}}\\
  Die Klasse Map enthält zum einen alle Regionen der Spielkarte, die zu Beginn
  des Spiels vom Server generiert werden, und zum anderen die
  Strombörse('EnergyExchange') und den Ressourcenmarkt. Außerdem werden in ihr
  die Kunden der einzlnen Spieler in den verschiedenen Städten berechnet.
  \item{\textbf{Klasse RessourceMarket}}\\
  Der Ressourcenmarkt setzt sich aus den drei unterschiedlichen Rohstoffen
  zusammen, die in unserem Spiel vorhanden sind. Die Preise für die Rohstoffe
  sind in dem Programm als Konstanten festgesetzt und ändern sich nicht mit der
  Zeit.
  \item{\textbf{Klasse EnergyExchange}}\\
  Die Strombörse im Spiel hat einen schwankenden Preis. Dieser reguliert sich
  aus Angebot und Nachfrage. Jedes Mal, wenn ein Spieler einen Stromhandel
  abschließt, schickt der Client eine kleine Nachricht über die Höhe des Handels
  an den Server, der daraufhin den neuen Preis für die nächste Runde berechnet.
  \item{\textbf{Klasse Region und Klasse Coords}}\\
  Die Klasse Region ist dafür gedacht, dass sie mithilfe ihrer Koordinaten, die
  in der Klasse Coords gespeichert sind, eindeutig ermittelt werden kann. Die
  Region ist nich dafür gedacht, dass sie für sich instanziiert wird, sondern
  mit Hilfe von Vererbung entweder als Ressourcenregion oder Stadtregion benutzt
  wird.
  \item{\textbf{Klasse CityRegion und Klasse Contract}}\\
  Die Stadtregion enthält alle Informationen über die Einwohner der Stadt und
  die Verträge mit den verschiedenen Energielieferanten. Die Stadt wird mit
  einer Einwohnerzahl und verschiedenen Kennziffern zum Spielstart generiert,
  während die Kundenzahlen, die in den Contracts gespeichert sind, sich jede
  Runde durch Preisänderungen der Spieler ändern können. Jede Stadt hat für
  jedes Unternehmen, das in ihr Kunden besitzt, ein seperates Contract-Objekt.
  \item{\textbf{Klasse RessourceRegion}}\\ 
  Die RessourceRegion wird mit einem bestimmten RessourceType (siehe
  Enumeration RessouurceType) und gegebenenfalls einer Menge des Rohstoffes zum
  Spielstart generiert. Für erneuerbare Energien wie z.B. Wasser entfällt
  natürlich die Rohstoffmenge. Während des Spiels können Spieler auf die
  Regionen bieten, um sie bebauen zu können. Diese Gebote werden an den Server
  gesendet, der dann den Zuschlag an ein Unternehmen gibt, der danach zum
  Besitzer der Region wird. Zudem meldet der Besitzer der Region dem Server,
  sobald er ein Gebäude in einer Region fertiggestellt hat. Dieser schreibt dies
  dann in das Region-Objekt, sodass dies auch für die anderen Spieler sichtbar
  wird.
  
\end{itemize}

\subsection{Unternehmen}

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth]{se-wa-jpg/OOD-Company}
\caption{Die Klasse Company}
\label{OOD-Company}
\end{figure}

Die 'Company'-Klasse, die in \ref{OOD-Company} zu sehen ist, ist auf
Client-Seite der Ausgangspunkt für alle Entscheidungen die ein Spieler treffen
kann. Von ihr werden alle Bereiche des Unternehmens referenziert und
angesprochen. Diese werden zumeist auch nur an die Untergeordneten Klassen
weitergeleitet, ohne sie selbst zu bearbeiten.
Allerdings beinhaltet die Company das Vermögen des Unternehmens, so dass alle
Einzahlungen und Auszahlungen in ihr erfolgen.
Des weiteren regelt die Klasse den Rundenanfang und das Rundenende. Zu Beginn
jeder Runde werden, zum Beispiel, die Einnahmen durch die Stromlieferungen dem
Konto gutgeschrieben. Zum Ende jeder Runde werden unter anderem die
Rohstoffmengen verbraucht und überprüft, ob überhaupt genug vorhanden sind.
Sollte dies nicht der Fall sein, kann die Runde nicht sofort beendet werden. Der
Spieler muss nun erst das Problem beheben, bevor das Spiel weitergehen kann.
Auch andere Faktoren, wie ein negativer Kontostand, oder nicht versorgte Kunden
können in der Company das Rundenende verhindern.

\subsection{Regionen}

\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{se-wa-jpg/OOD-Relation}
\caption{Klassendiagramm zu den Regionsbeziehungen}
\label{OOD-Relation}
\end{figure}

Da die Map, wie in \ref{cs} beschrieben, nur auf Serverseite bearbeitet wird,
hat jedes Unternehmen zu manchen Regionen eigene Beziehungen. Diese werden
genutzt um Unternehmensspezifische Daten zu jeder Region zu speichern. Mit Hilfe
der Koordinaten kann jede RegionRelation genau einer Region zugeordnet werden.
Wie in \ref{OOD-Relation} zu sehen ist, gibt es zwei Arten von Beziehungen: 
\begin{enumerate}
  \item {\textbf{RessourceRelation}}\\
  In der RessourceRelation werden neben Referenzen auf die
  Gebäude, die in der jeweiligen Region gebaut wurden, auch die verbleibende
  Rohstoffmenge gespeichert. Diese wird aus der jeweiligen Region
  übernommen und in die RegionRelation geschrieben. Dies ermöglicht, dass die
  Produktionsmenge einer Mine, direkt auf Client-Seite, von der restlichen
  Menge abgezogen werden kann.
  \item{\textbf{CityRelation}}\\
  Ursprünglich angedacht um unter anderem die Verträge der Spieler zu speichern,
  beinhaltet die CityRelation nun nur noch die Beliebtheit und die Bekanntheit
  des Unternehmens zu den jeweiligen Städten.
\end{enumerate}

\subsection{Gebäude}
\begin{figure}
\centering

\includegraphics[width=1.0\textwidth]{se-wa-jpg/OOD-Building}
\caption{Klassendiagramm zu den Gebäude}
\label{OOD-Building}
\end{figure}

Die Abteilung 'Investment', die für die Verwaltung der Gebäude in dem
Unternehmen zuständig ist, wurde im Vergleich zur Analysephase in einigen
Punkten geändert. Der 'InvestmentManager' aus der Analyse fällt in unserem Entwurf weg.
Die Funktion, die die Klasse übernommen hätte, das Hinzufügen von Gebäuden, wird
stattdessen von der 'Company'-Klasse übernommen.\\
Zudem gibt es nun keine Objekte mehr für die Grundstücke, die das Unternehmen
besitzt. Diese unterscheiden sich nicht voneinander, sodass die Spieler einfach
als Besitzer der Region in das jeweilige Objekt geschrieben werden können und
keine gesonderte Klasse benötigt wird.
Auch die Unterscheidung zwischen erneuerbaren Energien wird nun nicht mehr in
Form von Klassen, sondern mit Hilfe des 'RessourceType's des Kraftwerks
vorgenommen.

Alle verbliebenen Klassen werden im  Folgenden erläutert:
\begin{itemize}
  \item{\textbf{Klasse Investment und Klasse Building}}\\ 
  Die Klassen Investment und Building legen die Grundlagen für die beiden
  Gebäudetypen: die Mine und das Kraftwerk. Hierzu werden bereits im Investment
  der Kaufpreis, der aktuelle Buchwert und die dazugehörigen jährlichen
  Abschreibungen beschrieben. Die Klasse Building ergänzt diese Informationen
  noch um eine maximale Produktion und die derzeitige Auslastung. Darüber hinaus
  wird gespeichert, ob der Bau bereits beendet wurde und, wenn nicht, wie lange
  der Bau noch benötigt. Auch die aktuelle Produktion und die laufenden Kosten
  können hier abgelesen werden.
  \item{\textbf{Klasse Mine}}\\
  Zuzüglich zu dem Gebäude und dem Investment besitzt die Mine noch einen
  Ressourcentyp und eine Referenz auf die 'RessourceRelation', in der die
  verbleibende Menge des Rohstofffeldes gespeichert wird. Damit kann jede Runde
  die Menge an produzierten Rohstoffen berechnet werden.
  \item{\textbf{Klasse PowerStation}}\\ 
  Zum aktuellen Auslastungsfaktor im Gebäude wird im Kraftwerk noch ein
  Indikator für die Verstellbarkeit gespeichert. Dieser beschreibt, wie stark
  die laufenden Kosten eingespart werden können, indem die Auslastung gesenkt wird. Des
  Weiteren beinhaltet das Kraftwerk noch Wartungskosten, die, sofern sie
  eingespart werden, möglicherweise Reparaturen erforderlich machen. Auch den
  Verbrauch, der bei den fossilen Energien gebraucht wird, kann man hier
  ablesen.
  \item{\textbf{Klasse PowerStationRelation}}\\ 
	 Die PowerstationRelation stellt die Verbindung zwischen einem Kraftwerk und
	 einer Stadt mit Vertrag dar(siehe \ref{Opt}. Jedes Kraftwerk kann mehrere
	 solche Beziehungen besitzen.
\end{itemize}



%Matthias
\subsection{Finanzen}\label{matthias:finanzen}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{se-wa-jpg/finances}
\caption{Klassendiagramm zum Bereich der Finanzen}
\label{Finanzen}
\end{figure}
Die Finanzen sollen im Wesentlichen alle finanziell relevanten Aspekte des
Unternehmens abbilden. Hierzu gibt es das Department Finances, welches die
Bilanz, die Gewinn- und Verlustrechnung sowie alle vom Unternehmen aufgenommenen
Kredite verwaltet.

Im Einzelnen werden die relevantesten Methoden und ihre Aufgabe vorgestellt:\\
\textbf{Klasse Finances}
\begin{itemize}
  \item \textbf{addCredit(CreditType creditType):void}\\
  Mit dieser Methode lassen sich beliebig viele Kredite dem Unternehmen
  hinzufügen, wobei jeder Kredit als neues Objekt in die ArrayList ``credits''
  der Klasse Finances aufgenommen wird und der Kassenbestand des Unternehmens um die
  Darlehenshöhe erhöht wird. 
  \item \textbf{isCreditWorthyFor(CreditType creditType):boolean}
  Diese Methode gibt zurück, ob der vom Spiel vorgesehene maximale
  Verschuldungsgrad bei Aufnahme eines Kredits des Typs creditType überschritten
  würde. Damit kann im UI eine Überprüfung implementiert werden, die eine zu
  hohe Verschuldung eines Spielers verhindern kann.
  \item \textbf{isInsolvent():boolean}
  Gibt diese Methode true zurück, hat der Spieler eine zu hohe Verschuldung
  (welche durch Verluste und damit durch eine Reduktion des Eigenkapitals
  entstehen kann) und verfügt gleichzeitig über einen negativen Kassenbestand.
  Ist das der Fall, hat der Spieler das Spiel verloren.
  \item \textbf{nextRound() und nextYear()}
  werden automatisch aufgerufen und führen die Kreditzahlungen durch.
\end{itemize}
\textbf{Klasse Credit}
\begin{itemize}
  \item \textbf{payQuarter()}
  wird jede Runde aufgerufen und führt sowohl die Tilgung als auch die
  Zinszahlung durch. Bei abgezahlten Krediten betragen beide Werte 0, der
  Einfachheit halber (und der Tatsache, dass die Anzahl Kredite stark begrenzt
  ist) werden abbezahlte Kredite jedoch nicht aus der ArrayList credits der
  Klasse Finances entfernt.
\end{itemize}
\textbf{Klasse Balance}
\begin{itemize}
  \item \textbf{recalcBalance()}
  berechnet jedes Jahr die Werte der Grundstücke und Gebäude (AV), des Inventars
  und der Kasse (UV), des Eigenkapitals (EK) und des Fremdkapitals (FK).
\end{itemize}
\textbf{Klasse ProfitAndLoss}
\begin{itemize}
  \item \textbf{addXYZ(double amount)}
  Da nicht alle Aufwendungen und Erträge zum Ende jeden Jahres berechnet werden
  können, addieren diese Methoden die entsprechenden Werte für die jeweiligen
  A/E und speichern sie in den Attributen \textbf{nextXYZ}.
  \item \textbf{nextYear()}
  In dieser Methode wird jedes Jahr die Gewinn- und Verlustrechnung neu
  berechnet. Dazu werden die Werte der Variablen nextXYZ in die Variablen XYZ
  überschrieben und dann auf 0 gesetzt. Alle anderen Aufwendungen und Erträge
  werden nun berechnet. Anschließend wird der Gewinn bestimmt, von dem eine
  Steuer in Höhe von 30\% abgezogen wird, sofern ein Gewinn vorhanden ist.
  Anschließend wird der Kassenbestand des Unternehmens um die Höhe der
  anfallenden Steuern reduziert.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{se-wa-jpg/bilanz-guv}
\caption{Darstellung der Bilanz und GuV im UI}
\label{Bilanz und GuV}
\end{figure}

\subsection{Warenlager}\label{matthias:warehouse}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{se-wa-jpg/Warehouse}
\caption{Klassendiagramm zum Warenlager}
\label{Warenlager}
\end{figure}
Das Warehouse beinhaltet die Verwaltung aller Rohstoffe eines Unternehmens. Es
bildet die Lagerung durch eine Komposition mit der Klasse Ware ab, es enthält
Methoden zur Erhöhung und Reduzierung des Bestands sowie zum Kauf und Verkauf
von Resourcen.

\textbf{Klasse Warehouse}
\begin{itemize}
  \item \textbf{buyWare(\ldots) / sellWare(\ldots)}
  dient zum Kauf und Verkauf von Waren. Hierbei muss nicht nur der Kassenbestand
  des Unternehmens aktualisiert werden, es entstehen gleichzeitig auch
  Aufwendungen / Erträge.
  \item \textbf{getStoredValue()}
  gibt den Wert der gelagerten Rohstoffe zurück. Dies wird zur Berechnung der
  Bilanz benötigt.
  \item \textbf{nextRound()}
  die Lagerkosten werden um einen von der Menge der gelagerten Güter abhängigen
  Wert erhöht.
  \item \textbf{nextYear()}
  Die Bestandsveränderungen im Vergleich zum letzten Jahr werden berechnet. Dies
  ist für die Gewinn- und Verlustrechnung erforderlich, da hier Aufwendungen
  bzw. Erträge entstehen.
\end{itemize}

%Olli
\subsection{Kartenerzeugung}\label{olli:kartenerzeugung}
Die Erzeugung der Karte geschieht in dem Pkaet \textbf{de.shared.map.generate}.
Hier gibt es zunächst das Interface \textbf{MapType}, dass von zwei anderen
Enumerations implementiert wird:
\begin{itemize}
  \item \textbf{MapTypeHexagon}: Diese Klasse stellt die Karte dar, die
  wie ein großes Hexagon geformt ist --- dabei gibt es die verschiedene
  Kartengrößen \textbf{SMALL}, \textbf{NORMAL} und \textbf{LARGE}. Hier werden
  verschiedene Methoden angeboten, die größtenteils in dem GUI (siehe
  \ref{GUIKarte}) verwendet werden: Beispielsweise gibt die rekursive Funktion
  \textbf{getAmountTilesForRow(int rowIndex)} die Anzahl von Feldern zurück, die
  in einer bestimmten Reihe liegen. 
  \item \textbf{MapTypeRect}: Der zweite Kartentyp ist rechteckig geformt. Diese
  ist einfacher entwickelt und besitzt die gleichen Kartengrößen wie die
  \textbf{MapTypeHexagon}.
\end{itemize}
Des Weiteren bestimmt die Klasse \textbf{CityNameGenerator} zufällig Städtenamen
aus einer Liste von Strings.

Die eigentliche Kartenerzeugung findet in \textbf{RegionGenerator} statt.
Zunächst werden in der Methode \textbf{generateRegions} die Portionen der Karte
festgelegt, die jeder Feldtyp besitzt. Beispielsweise sind also $1/7$ der Felder
Kohlefelder. 

Einleitend wird nun das Koordinatensystem der Karte erklärt. Da die Karte aus
hexagonförmigen Feldern mit je sechs Seiten besteht kann hier nicht das
klassische kartesische Koordinatensystem genutzt werden. Es bleiben immer noch
zwei Achsen X und Y, diese laufen aber nicht im rechten Winkel zueinander:
%\citehttp://keekerdc.com/2011/03/hexagon-grids-coordinate-systems-and-distance-calculations/


%Bild Koordinatensystem
\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{se-wa-jpg/hexagonkarte}
\caption{Koordinatensystem der Karte}
\label{Koordinatensystem}
\end{figure}
Des Weiteren kann die Distanz von einem Feld zu einem anderen folgendermaßen
berechnet werden:
\begin{align*}
\Delta x = x_1 - x_2 \\
\Delta y = y_1 - y_2
\end{align*}
Sind die Vorzeichen von $\Delta x$ und $\Delta y$ verschieden, ist die Distanz
durch den größeren (positiven) Wert gegeben. Im anderen Fall, wenn $\Delta x$
und $\Delta y$ das gleiche Vorzeichen besitzen, ist die Distanz durch die Summe
der Beträge der beiden Werte berechenbar.

Um die eigentliche Karte zu erstellen, werden als nächstes die Positionen der
Städte zufällig generiert. Dazu werden seine X- und Y-Koordinaten durch eine
Zufallszahl bestimmt --- jedoch muss die Stadt mindestens ein Feld von jeder 
anderen bisher generierten Stadt entfernt sein. 

Anschließend werden die Ressourcenfelder erzeugt. Dafür wird eine
\textbf{HashMap} angelegt, die als Datensätze die verschiedenen Rohstofftypen
und dessen Felderanzahl enthält. Es wird jetzt jedes Feld durchlaufen, das noch
keine Stadt ist. Der Rohstofftyp des Feldes wird durch eine zufällige Wahl von einem
der Datensätze der \textbf{HashMap} bestimmt, dessen verbleibende Felderanzahl
dann entsprechend reduziert wird.